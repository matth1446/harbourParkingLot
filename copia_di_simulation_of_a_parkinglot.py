# -*- coding: utf-8 -*-
"""Copia di simulation_of_a_parkinglot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BCB-H3Bz0cM0ZHoMrI4z2j_JJHvUf1Q6
"""

#pip install simpy

"""Companion code to https://realpython.com/simulation-with-simpy/

'Simulating Real-World Processes With SimPy'

Python version: 3.7.3
SimPy version: 3.0.11
"""

import simpy
import random
import statistics
from functools import reduce

wait_times = []

# I didn't choose any of the time-inputs, so don't look at me

class VehicleType:
    def __init__(self, wait_time, size):
        self.wait_time = wait_time
        self.size = size

class Vehicle:
    def __init__(self, id, type, graph, start, end):
        self.path = graph.make_path(start, end)
        self.current_position = -1
        self.type = type
        self.id = id

    def has_left(self):
        return self.current_position == len(self.path)

    def advance(self):
        self.current_position += 1
        return (
            None if self.current_position == 0 else self.path[self.current_position - 1],
            None if self.has_left() else self.path[self.current_position]
        )

class DummyNode:
    def __init__(self, id, capacity):
        self.id = id
        self.capacity = capacity

    def define_store(self, store):
        self.store = store


class DummyGraph:
    def __init__(self):
        self.nodes = [DummyNode(0, 2), DummyNode(1, 2), DummyNode(2, 1), DummyNode(3, 1)]
        self.connections = [[2], [2], [3]]
        pass

    def link_resources(self, parking_lot, env):
        for node in self.nodes:
            node.define_store(simpy.Store(env, node.capacity))

    def make_path(self, start, end):
        if start == 0 or start == 1:
            return [self.nodes[start], self.nodes[2], self.nodes[3]]
        elif start == 2:
            return [self.nodes[2], self[3]]
        else:
            return [self[3]]

class ParkingLot(object):

    def __init__(self, env):
        self.env = env

    # what can the cars do

    # once the car comes in the entrance gate, the goal is to park it:
    # find a parking slot available (we should think of the type of vehicle/parking space)
    def park(self, car):
        yield self.env.timeout(random.randint(1, 3))

    # the car moves through roads, towards the check in gates:
    # every car is going to have multiple calls to this function, based on where it was parked and the connections between the roads
    def change_road(self, car, road):
        yield self.env.timeout(car.type.wait_time + self.get_total_wait_time(road))

    # cars arriving to the final queue/gate/goal:
    # after moving in the parking lot they reach the check-in gates, and then leave the system (get on board)
    def check_in(self, car):
        yield self.env.timeout(3 / 60)

    def get_total_wait_time(self, road):
        return reduce(lambda x, y: y.wait_time + x, road.store.items, 0)


# what actually happens to a car inside the parkinglot
def car_through_the_pl(env, car, parkinglot):

    # car arrives at the parkinglot
    arrival_time = env.now

    while(not car.has_left()):
        previous_road, next_road = car.advance()
        
        if next_road is not None:
            put_request = yield next_road.store.put(car.type)
            yield env.process(parkinglot.change_road(car, next_road))
            print(f"car {car.id} has entered road {next_road.id} at {env.now}")

        if previous_road is not None:
            print(f"car {car.id} has left road {previous_road.id} at {env.now}")
            release_request = previous_road.store.get()
        

    # Car is boarded : "thread" is finished
    wait_times.append(env.now - arrival_time)


def run_parkinglot(env):

    # I think here the input parameters should be something derived from the graph
    parkinglot = ParkingLot(env)
    graph = DummyGraph()
    graph.link_resources(parkinglot, env)
    car_id = 0
    car = Vehicle(car_id, VehicleType(1, 1), graph, 0, 3)
    # we can use the avg_num_of_cars we expect
    while True:
        yield env.timeout(0.2)  # Wait a bit before generating a new person / we can do the exp distribution for the arrivals

        car_id += 1
        car = Vehicle(car_id, VehicleType(1, 1), graph, 0, 3)
        env.process(car_through_the_pl(env, car, parkinglot))


def get_average_wait_time(wait_times):
    average_wait = statistics.mean(wait_times)
    # Pretty print the results
    minutes, frac_minutes = divmod(average_wait, 1)
    seconds = frac_minutes * 60
    return round(minutes), round(seconds)

# this is not my code, of course we need to elaborate the graph input
def get_user_input():
    num_roads = input("Input # of roads: ")
    # we will have different gates for trucks and cars
    num_gates = input("Input # of gates: ")
    params = [num_roads, num_gates]
    if all(str(i).isdigit() for i in params):  # Check input is valid
        params = [int(x) for x in params]
    else:
        print(
            "Could not parse input. Simulation will use default values:",
            "\n1 roads, 1 gates.",
        )
        params = [1, 1]
    return params

def input():
  # Read the json file
  # extract the graph and turn it into roads and connections
  # and get the other attributes inserted by the user

  # Budget stuff that will be used at the end of the simulation:
  # wages, ticket prices

  # Capacity stuff:
  # N of parking slots per type
  # N of check-in gates

  # Flow stuff:
  # arrivals are exp
  # departures depend on the roads
  avg_num_of_cars = 90
  avg_num_of_trucks = 5
  avg_num_of_trailers = 10

  perc_online_tickets = 0.60

  # Time stuff:
  # how long is the simulation?
  # opening time-closing time of the check-in gates
  # closing time of the entrace gates
  # 'how long' the roads are (time value)?
  # how long does it take to serve at the check-in gates?

def main():
    # Setup
    random.seed(42)

    # Get inputs from the graph
    #num_roads, num_gates = get_user_input()

    # Run the simulation
    env = simpy.Environment()
    env.process(run_parkinglot(env))
    # it decides here when to stop the simulation, I think we can either leave this decision to the avg num of cars we expect (so the run_parkinglot())
    # or to the main, speaking in terms of time, meaning for ex when the check-in gates close.
    env.run(until=30)

    # View the results
    mins, secs = get_average_wait_time(wait_times)
    print(
        "Running simulation...",
        f"\nThe average wait time is {mins} minutes and {secs} seconds.",
    )

    # Of course we can add all the details we need for our ..*calculations^.^


if __name__ == "__main__":
    main()

12
